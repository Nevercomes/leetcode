/**
 * 这道题要DP的话就是 f(i) = f(i-1) + t[i] || f(i-1)
 * 关键是怎么判断 要不要加上自己呢？如果没有 O(1)的方法那就没有优化的意义了
 *
 * 好吧，DP的时间复杂度就是比 双指针要高一点，而且代码也比较长
 *
 * 我们可以使用动态规划的方法实现预处理，令 f[i][j] 表示字符串 t 中从位置 i 开始往后字符 j 第一次出现的位置。
 * 在进行状态转移时，如果 t 中位置 i 的字符就是 j，那么 f[i][j]=i，否则 j 出现在位置 i+1 开始往后，即 f[i][j]=f[i+1][j]
 * 因此我们要倒过来进行动态规划，从后往前枚举 i
 *
 *
 * @author Sunss
 * @since 2021/3/28
 */
public class Solution {
}
